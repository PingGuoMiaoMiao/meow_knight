let silme_idle_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/FreeSlime/slime_idle.png",
    4,
    width=32,
    height=32,
  ),
  loop_=true,
  fps=12,
)

let silme_run_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/FreeSlime/slime_run.png",
    6,
    width=32,
    height=32
  ),
  loop_=true,
  fps=12,
)

let silme_die_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/FreeSlime/slime_die.png",
    5,
    width=32,
    height=32
  ),
  loop_=false,
  fps=12,
)


let silmes : Map[@system.Entity, Silme] = Map::new()

///|
const Silme_SPEED = 50.0

enum SilmeState {
  Idle
  Run
  Die
}

struct Silme{
  mut health : Int
  speed : Double
  mut direction : Direction2
  mut is_hurt : Bool
  mut hurt_timer : Double
  mut state : SilmeState
  mut idle_timer : Double
  mut rotation : Double  // æ—‹è½¬è§’åº¦ï¼ˆå¼§åº¦ï¼‰
}


fn add_silme(pos : @math.Vec2D) -> Unit{
  let entity = @system.Entity::new()
  let silme_sprite = @sprite.Sprite::from_animation(
    silme_idle_animation, 10,
  )
  @sprite.sprites.set(entity, silme_sprite)
  @velocity.velocities.set(entity, @math.Vec2D::zero()) // åˆå§‹é€Ÿåº¦ä¸º0ï¼Œé™æ­¢çŠ¶æ€
  @position.positions.set(entity, pos)
  // æ·»åŠ ç¢°æ’ä½“ç§¯ï¼Œä½¿ slime èƒ½ä¸åœ°å½¢å‘ç”Ÿç¢°æ’
  // ä¸»ç‰©ç†ä½“ç§¯ä¸ slime å›¾ç‰‡å®Œå…¨ä¸€è‡´
  @collision.shapes.set(
    entity,
    Rect(size=@math.Vec2D(24.0, 24.0), offset=@math.Vec2D(0.0, 0.0)),
  )
  @collision.collision_layers.set(entity, enemy_collision_layer)  // ä½¿ç”¨æ•Œäººç¢°æ’å±‚ï¼Œè€Œä¸æ˜¯åœ°å½¢å±‚
  @collision.colliders.set(
    entity,
    @collision.Collider::new(
      @collision.CollisionMask::new([
        terrain_collision_layer,  // slime ä¸åœ°å½¢ç¢°æ’ï¼Œèƒ½ç«™åœ¨åœ°ä¸Š
        player_collision_layer,   // slime ä¹Ÿèƒ½æ£€æµ‹åˆ°ä¸ç©å®¶çš„ç¢°æ’
      ]),
    ),
  )
  silmes[entity] = Silme::{
    health: 100,
    speed: Older_SPEED,
    direction: Direction2::Left,
    is_hurt: false,
    hurt_timer: 0.0,
    state: SilmeState::Idle,
    idle_timer: 0.0,
    rotation: 0.0,
  }
}


fn silme_ai_system(delta : Double) -> Unit{
  for e, silme in silmes {
    guard e.is_alive() else { continue }
    
    // æ·»åŠ é‡åŠ›ç³»ç»Ÿ
    guard @velocity.velocities.get(e) is Some(velocity) else { 
      println("âš ï¸ Slime æ²¡æœ‰é€Ÿåº¦ç»„ä»¶ï¼")
      continue 
    }
    
    // è·å–ä½ç½®ä¿¡æ¯ç”¨äºè°ƒè¯•
    let pos = @position.positions.get(e).unwrap_or(@math.Vec2D::zero())
    let is_on_floor = @collision.is_on_floor(e)
    
    let mut new_velocity_y = velocity.0[Y]
    new_velocity_y += 1800.0 * delta  // ä½¿ç”¨å’Œ player ç›¸åŒçš„é‡åŠ›å¸¸æ•°
    
    // æ‰“å°è°ƒè¯•ä¿¡æ¯
    if silme.idle_timer.to_int() % 60 == 0 {  // æ¯ç§’æ‰“å°ä¸€æ¬¡
      println("ğŸ® SlimeçŠ¶æ€: ä½ç½®(" + pos.0[X].to_string() + "," + pos.0[Y].to_string() + ") " +
              "é€Ÿåº¦(" + velocity.0[X].to_string() + "," + velocity.0[Y].to_string() + ") " +
              "åœ¨åœ°é¢: " + is_on_floor.to_string())
    }
    
    // æ›´æ–°å—ä¼¤è®¡æ—¶å™¨
    if silme.hurt_timer > 0.0 {
      silme.hurt_timer -= 1.0
    }
    
    // æ­»äº¡çŠ¶æ€
    if silme.health <= 0 {
      silme.state = SilmeState::Die
      @velocity.velocities[e] = @math.Vec2D::zero()
      @collision.collision_layers.remove(e)
      @sprite.play_animation(
        e,
        silme_die_animation,
        transform=@math.Transform::new()
      )
      if @sprite.is_animation_finished(e) {
        // æ­»äº¡åŠ¨ç”»ç»“æŸï¼Œæ˜¾ç¤ºå¯¹è¯
        show_slime_death_dialogue()
        
        // æ‰è½2ä¸ªé‡‘å¸
        let drop_pos = @position.positions.get(e).unwrap_or(@math.Vec2D::zero())
        add_coin(@math.Vec2D(drop_pos.0[X] - 10.0, drop_pos.0[Y] - 8.0))
        add_coin(@math.Vec2D(drop_pos.0[X] + 10.0, drop_pos.0[Y] - 8.0))
        
        e.destroy()
        silmes.remove(e)
      }
      continue
    }
    
    // å—ä¼¤çŠ¶æ€ - ä¿æŒå‡»é€€æ•ˆæœï¼Œæ·»åŠ å¤šåœˆæ—‹è½¬åŠ¨ç”»
    if silme.is_hurt && silme.hurt_timer > 0.0 {
      silme.state = SilmeState::Idle
      // ä¸é‡ç½®é€Ÿåº¦ï¼Œè®©å‡»é€€æ•ˆæœè‡ªç„¶è¡°å‡
      // åªåº”ç”¨é‡åŠ›
      @velocity.velocities[e] = @math.Vec2D(velocity.0[X], new_velocity_y)
      
      // è®¡ç®—æ—‹è½¬è¿›åº¦ï¼šä»60.0é€’å‡åˆ°0ï¼Œç”¨æ¥è®¡ç®—æ—‹è½¬è§’åº¦
      // è®©slimeåœ¨60å¸§å†…è½¬3åœˆï¼Œå³æ¯å¸§è½¬18åº¦
      let rotation_progress = (60.0 - silme.hurt_timer) / 60.0  // 0.0 åˆ° 1.0
      silme.rotation = rotation_progress * 18.84954  // 18.84954 = 3 Ã— 2Ï€ (è½¬3åœˆ)
      
      // æ ¹æ®æ—‹è½¬è§’åº¦å†³å®šç¿»è½¬çŠ¶æ€
      // å½“æ—‹è½¬è§’åº¦çš„ä½™æ•°åœ¨90-270åº¦ä¹‹é—´æ—¶ç¿»è½¬
      let rotation_degrees = (silme.rotation * 57.2958) % 360.0  // è½¬æ¢ä¸ºè§’åº¦å¹¶å–ä½™æ•°
      let should_flip = rotation_degrees > 90.0 && rotation_degrees < 270.0
      
      // æ·»åŠ é—ªçƒæ•ˆæœï¼šæ¯éš”å‡ å¸§åˆ‡æ¢ä¸€æ¬¡å¯è§æ€§ï¼ˆæ¨¡æ‹Ÿå—ä¼¤é—ªçƒï¼‰
      let blink_phase = (silme.hurt_timer.to_int() / 5) % 2
      let is_visible = blink_phase == 0
      
      if is_visible {
        let rotate_transform = if should_flip {
          @math.Transform::flip_x(16.0)  // ä½¿ç”¨slimeä¸­å¿ƒç‚¹ç¿»è½¬
        } else {
          @math.Transform::new()
        }
        
        @sprite.play_animation(
          e,
          silme_idle_animation,
          transform=rotate_transform
        )
      }
      continue
    } else if silme.is_hurt && silme.hurt_timer <= 0.0 {
      // å—ä¼¤çŠ¶æ€ç»“æŸï¼Œå›åˆ°å¾…æœºï¼Œé‡ç½®æ—‹è½¬
      silme.is_hurt = false
      silme.state = SilmeState::Idle
      silme.rotation = 0.0  // é‡ç½®æ—‹è½¬è§’åº¦
    }
    
    // ç§»åŠ¨é€»è¾‘ï¼šå·¦å³æ¥å›èµ°åŠ¨
    silme.idle_timer += delta
    
    let mut new_velocity_x = 0.0
    if silme.idle_timer > 2.0 {  // æ¯2ç§’æ”¹å˜æ–¹å‘
      silme.direction = match silme.direction {
        Direction2::Left => Direction2::Right
        Direction2::Right => Direction2::Left
      }
      silme.idle_timer = 0.0
      let direction_str = match silme.direction {
        Direction2::Left => "Left"
        Direction2::Right => "Right"
      }
      println("ğŸ”„ Slime æ”¹å˜æ–¹å‘: " + direction_str)
    }
    
    // æ ¹æ®æ–¹å‘è®¾ç½®é€Ÿåº¦
    match silme.direction {
      Direction2::Left => {
        new_velocity_x = -Silme_SPEED
        silme.state = SilmeState::Run
      }
      Direction2::Right => {
        new_velocity_x = Silme_SPEED
        silme.state = SilmeState::Run
      }
    }
    
    // è®¾ç½®é€Ÿåº¦
    @velocity.velocities[e] = @math.Vec2D(new_velocity_x, new_velocity_y)
    
    // æ’­æ”¾å¯¹åº”åŠ¨ç”»
    let transform = match silme.direction {
      Direction2::Left => @math.Transform::flip_x(32.0)
      Direction2::Right => @math.Transform::new()
    }
    
    match silme.state {
      SilmeState::Run => {
        @sprite.play_animation(e, silme_run_animation, transform=transform)
      }
      _ => {
        @sprite.play_animation(e, silme_idle_animation, transform=transform)
      }
    }
  }
}