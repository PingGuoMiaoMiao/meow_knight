let cat_idle_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/Cats/cat_sprite_sheet.png",
    4,
    width=32,
    height=32,
  ),
  loop_=true,
  fps=8,
)

let cat_run_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/Cats/cat_sprite_sheet.png",
    8,
    width=32,
    height=32,
    offset=@math.Vec2D(0.0, 32.0)  // ç¬¬äºŒè¡ŒåŠ¨ç”»
  ),
  loop_=true,
  fps=12,
)


let cats : Map[@system.Entity, Cat] = Map::new()

///|
const CAT_SPEED = 12.0
const CAT_GRAVITY = 1800.0  // Cat çš„é‡åŠ›åŠ é€Ÿåº¦

enum CatState {
  Idle
  Run
  Sleep
}

struct Cat{
  health : Int
  speed : Double
  mut direction : Direction2
  mut is_hurt : Bool
  mut hurt_timer : Double
  mut state : CatState
  mut idle_timer : Double
}


fn add_cat(pos : @math.Vec2D) -> Unit{
  println("ğŸ± Creating cat entity at position: \{pos}")
  let entity = @system.Entity::new()
  let cat_sprite = @sprite.Sprite::from_animation(
    cat_idle_animation, 10,
  )
  @sprite.sprites.set(entity, cat_sprite)
  @velocity.velocities.set(entity, @math.Vec2D::zero())
  @position.positions.set(entity, pos)
  
  println("ğŸ± Cat entity components set")
  
  // Cat éœ€è¦ç¢°æ’ä½“ç§¯æ¥ç«™åœ¨åœ°é¢ä¸Šï¼Œä½†ä¸ä¼šé˜»æŒ¡ç©å®¶
  @collision.shapes.set(
    entity,
    Rect(size=@math.Vec2D(32.0, 32.0), offset=@math.Vec2D(0.0, 0.0)),
  )
  @collision.collision_layers.set(entity, cat_collision_layer)  // ä½¿ç”¨ç‹¬ç«‹çš„ cat å±‚
  @collision.colliders.set(
    entity,
    @collision.Collider::new(
      @collision.CollisionMask::new([terrain_collision_layer])  // åªä¸åœ°å½¢ç¢°æ’
    ),
  )
  
  // æ·»åŠ äº¤äº’åŒºåŸŸç”¨äºä¸ç©å®¶äº¤äº’
  let area = @collision.Area::new(
    @collision.CollisionMask::new([player_collision_layer])
  )
  @collision.areas.set(entity, area)
  
  cats[entity] = Cat::{
    health: 50,
    speed: CAT_SPEED,
    direction: Direction2::Right,
    is_hurt: false,
    hurt_timer: 0.0,
    state: CatState::Idle,
    idle_timer: 0.0,
  }
  
  println("ğŸ± Cat added successfully")
}


fn cat_ai_system(delta : Double) -> Unit{
  if cats.is_empty() {
    return  // æ²¡æœ‰ cat å°±ç›´æ¥è¿”å›
  }
  
  for e, cat in cats {
    guard e.is_alive() else { continue }
    
    // åº”ç”¨é‡åŠ›
    guard @velocity.velocities.get(e) is Some(velocity) else { continue }
    
    // è·å– cat ä½ç½®
    guard @position.positions.get(e) is Some(cat_pos) else { continue }
    
    // åº”ç”¨é‡åŠ›åˆ° Y è½´é€Ÿåº¦
    let mut new_velocity_y = velocity.0[Y]
    new_velocity_y += CAT_GRAVITY * delta
    
    // æ£€æµ‹å‘¨å›´æ˜¯å¦æœ‰å…¶ä»–è§’è‰²ï¼ˆç©å®¶ï¼‰
    let mut has_nearby_entity = false
    let detection_range = 100.0  // æ£€æµ‹èŒƒå›´
    
    // æ£€æµ‹ç©å®¶
    match @position.positions.get(game_state.player) {
      Some(player_pos) => {
        let dx = cat_pos.0[X] - player_pos.0[X]
        let dy = cat_pos.0[Y] - player_pos.0[Y]
        let distance_squared = dx * dx + dy * dy
        if distance_squared < detection_range * detection_range {
          has_nearby_entity = true
        }
      }
      None => ()
    }
    
    // å¦‚æœæœ‰è§’è‰²åœ¨é™„è¿‘ï¼Œåˆ‡æ¢åˆ° Run çŠ¶æ€
    if has_nearby_entity {
      cat.state = CatState::Run
      cat.idle_timer = 0.0  // é‡ç½® idle è®¡æ—¶å™¨
    } else {
      // æ²¡æœ‰è§’è‰²åœ¨é™„è¿‘ï¼Œæ›´æ–° idle è®¡æ—¶å™¨
      cat.idle_timer += delta
      
      // è¶…è¿‡ 3 ç§’ï¼Œåˆ‡æ¢åˆ° Sleep çŠ¶æ€
      if cat.idle_timer > 3.0 {
        cat.state = CatState::Sleep
      }
    }
    
    // æ ¹æ®çŠ¶æ€æ‰§è¡Œä¸åŒçš„è¡Œä¸º
    match cat.state {
      CatState::Run => {
        // å·¦å³èµ°åŠ¨
        let direction_multiplier = match cat.direction {
          Direction2::Left => -1.0
          Direction2::Right => 1.0
        }
        let mut velocity_x = cat.speed * direction_multiplier
        
        // ç®€å•çš„è½¬å‘é€»è¾‘ï¼šç¢°åˆ°è¾¹ç•Œè½¬å‘
        if cat_pos.0[X] < 100.0 {
          cat.direction = Direction2::Right
        } else if cat_pos.0[X] > 200.0 {
          cat.direction = Direction2::Left
        }
        
        let new_direction_multiplier = match cat.direction {
          Direction2::Left => -1.0
          Direction2::Right => 1.0
        }
        velocity_x = cat.speed * new_direction_multiplier
        @velocity.velocities[e] = @math.Vec2D(velocity_x, new_velocity_y)
        
        // æ’­æ”¾å¥”è·‘åŠ¨ç”»ï¼Œæ ¹æ®æ–¹å‘ç¿»è½¬
        let transform = match cat.direction {
          Direction2::Left => @math.Transform::flip_x(16.0)  // ä½¿ç”¨catä¸­å¿ƒç‚¹ç¿»è½¬
          Direction2::Right => @math.Transform::new()
        }
        @sprite.play_animation(
          e,
          cat_run_animation,
          transform=transform
        )
      }
      CatState::Idle => {
        // é™æ­¢ï¼Œæ’­æ”¾ idle åŠ¨ç”»
        @velocity.velocities[e] = @math.Vec2D(0.0, new_velocity_y)
        @sprite.play_animation(
          e,
          cat_idle_animation,
          transform=@math.Transform::new()
        )
      }
      CatState::Sleep => {
        // ç¡è§‰ï¼Œæ’­æ”¾ idle åŠ¨ç”»
        @velocity.velocities[e] = @math.Vec2D(0.0, new_velocity_y)
        @sprite.play_animation(
          e,
          cat_idle_animation,
          transform=@math.Transform::new()
        )
      }
    }
  }
}