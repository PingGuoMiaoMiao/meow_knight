let older_idle_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/Older/IDLE.png",
    10,
    width=96,
     height=96,
  ),
  loop_=true,
  fps=12,
)

let older_attack_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/Older/ATTACK1.png",
    7,
    width=96,
    height=96,
  ),
  loop_=true,
  fps=12,
)

let older_run_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/Older/RUN.png",
    16,
    width=96,
    height=96,
  ),
  loop_=true,
  fps=12
) 

let older_hurt_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/Older/HURT.png",
    4,
    width=96,
    height=96,
  ),
  loop_=true,
  fps=12
)

///|
const Older_SPEED = 30.0
const Older_BLINK_COOLDOWN = 3.0  // é—ªç°å†·å´æ—¶é—´3ç§’
const Older_BLINK_RANGE = 200.0   // é—ªç°æ£€æµ‹èŒƒå›´
const Older_ATTACK_DAMAGE = 1     // æ”»å‡»ä¼¤å®³
const Older_ATTACK_RANGE = 100.0  // æ”»å‡»èŒƒå›´
const Older_ATTACK_DURATION = 0.3 // æ”»å‡»æŒç»­æ—¶é—´ï¼ˆ0.3ç§’å†…å¯ä»¥é€ æˆä¼¤å®³ï¼‰

struct Older {
  mut health : Int
  speed : Double
  mut direction : Direction2
  mut is_hurt : Bool
  mut hurt_timer : Double
  mut state : OlderState
  mut idle_timer : Double
  mut blink_timer : Double  // é—ªç°å†·å´è®¡æ—¶å™¨
  mut attack_timer : Double // æ”»å‡»è®¡æ—¶å™¨ï¼Œç”¨äºåˆ¤å®šæ”»å‡»ä¼¤å®³çš„æ—¶æœº
  mut has_attacked : Bool   // æœ¬æ¬¡æ”»å‡»æ˜¯å¦å·²ç»é€ æˆä¼¤å®³
  mut has_talked : Bool     // æ˜¯å¦å·²ç»å¯¹è¯ï¼Œåªæœ‰å¯¹è¯åæ‰ä¼šæ”»å‡»
}

enum OlderState {
  Idle
  Run
  Attack
  HURT
}

///|
let olders : Map[@system.Entity, Older] = Map::new()

fn add_Older(pos : @math.Vec2D) -> @system.Entity {
  let entity = @system.Entity::new()
  let older_sprite = @sprite.Sprite::from_animation(
    older_idle_animation, 10,
  )
  @sprite.sprites.set(entity, older_sprite)
  @velocity.velocities.set(entity, @math.Vec2D::zero()) // åˆå§‹é€Ÿåº¦ä¸º0ï¼Œé™æ­¢çŠ¶æ€
  @position.positions.set(entity, pos)
  
  // Older ä¸éœ€è¦ç¢°æ’ä½“ç§¯ï¼Œåªä¿ç•™ä¸»ç‰©ç†ä½“ç§¯
  // å¯ä»¥æ·»åŠ äº¤äº’åŒºåŸŸç”¨äºä¸ç©å®¶äº¤äº’
  let area = @collision.Area::new(
    @collision.CollisionMask::new([player_collision_layer])
  )
  @collision.areas.set(entity, area)
  
  olders[entity] = Older::{
    health: 100,
    speed: Older_SPEED,
    direction: Direction2::Right,
    is_hurt: false,
    hurt_timer: 0.0,
    state: OlderState::Idle,
    idle_timer: 0.0,
    blink_timer: 0.0,  // åˆå§‹å¯ä»¥ç«‹å³é—ªç°
    attack_timer: 0.0,
    has_attacked: false,
    has_talked: false,  // åˆå§‹æœªå¯¹è¯
  }
  
  entity  // è¿”å›åˆ›å»ºçš„å®ä½“
}

fn older_ai_system(delta : Double) -> Unit{
  // é¦–å…ˆæ£€æŸ¥ç©å®¶æ”»å‡»æ˜¯å¦å‡»ä¸­ Older
  if attack_state.is_attacking {
    let player_pos = @position.positions.get(game_state.player).unwrap_or(@math.Vec2D::zero())
    let attack_range = match attack_state.attack_type {
      1 => 120.0
      2 => 150.0
      _ => 120.0
    }
    
    for e, older in olders {
      guard e.is_alive() else { continue }
      guard older.hurt_timer <= 0.0 else { continue }  // è·³è¿‡æ— æ•Œæ—¶é—´çš„Older
      
      let older_pos = @position.positions.get(e).unwrap_or(@math.Vec2D::zero())
      let dx = older_pos.0[X] - player_pos.0[X]
      let dy = older_pos.0[Y] - player_pos.0[Y]
      let distance_squared = dx * dx + dy * dy
      let max_distance_squared = attack_range * attack_range
      
      if distance_squared <= max_distance_squared {
        let is_correct_direction = match game_state.direction {
          Direction2::Right => dx > 0.0
          Direction2::Left => dx < 0.0
        }
        
        if is_correct_direction {
          let damage = match attack_state.attack_type {
            1 => 25
            2 => 40
            _ => 25
          }
          
          older.is_hurt = true
          older.hurt_timer = 0.5
          older.health -= damage
          older.state = OlderState::HURT
          println("ğŸ‘´ Older å—åˆ°æ”»å‡»ï¼ä¼¤å®³: \{damage}ï¼Œå‰©ä½™ç”Ÿå‘½: \{older.health}")
          
          // Older ä½œä¸º Boss ä¸ä¼šè¢«å‡»é€€ï¼Œåªæ˜¯åœæ­¢ç§»åŠ¨å¹¶æ’­æ”¾å—å‡»åŠ¨ç”»
          @velocity.velocities[e] = @math.Vec2D(0.0, 0.0)
        }
      }
    }
  }
  
  for e, older in olders {
    guard e.is_alive() else { continue }
    
    // Older ä¸éœ€è¦é‡åŠ›ï¼Œä¿æŒåœ¨å›ºå®šä½ç½®
    guard @velocity.velocities.get(e) is Some(velocity) else { continue }
    
    // è·å– Older ä½ç½®
    guard @position.positions.get(e) is Some(older_pos) else { continue }
    
    // æ›´æ–°å—ä¼¤è®¡æ—¶å™¨
    if older.hurt_timer > 0.0 {
      older.hurt_timer -= delta
    }
    
    // æ›´æ–°é—ªç°å†·å´è®¡æ—¶å™¨
    if older.blink_timer > 0.0 {
      older.blink_timer -= delta
    }
    
    // æ­»äº¡çŠ¶æ€
    if older.health <= 0 {
      @velocity.velocities[e] = @math.Vec2D::zero()
      @sprite.play_animation(
        e,
        older_idle_animation,
        transform=@math.Transform::new()
      )
      
      // æ˜¾ç¤ºæ­»äº¡å¯¹è¯
      show_dialogue("Older", "åŸæ¥æ˜¯è¿™æ ·å—...\nçœ‹æ¥å–µå–µå…¬ä¸»æœ‰æ•‘äº†", Some(older_idle_animation))
      
      // ä»åœºæ™¯åˆ‡æ¢è·Ÿè¸ªç³»ç»Ÿä¸­ç§»é™¤
      older_entities.remove(e)
      println("ğŸ’€ Older å·²æ­»äº¡ï¼Œä»åœºæ™¯åˆ‡æ¢è·Ÿè¸ªç³»ç»Ÿä¸­ç§»é™¤")
      
      e.destroy()
      olders.remove(e)
      continue
    }
    
    // å—ä¼¤çŠ¶æ€
    if older.is_hurt && older.hurt_timer > 0.0 {
      older.state = OlderState::HURT
      // Older ä½œä¸º Bossï¼Œå—ä¼¤æ—¶å®Œå…¨é™æ­¢ï¼Œä¸ä¿ç•™ä»»ä½•é€Ÿåº¦
      @velocity.velocities[e] = @math.Vec2D(0.0, 0.0)
      let transform = match older.direction {
        Direction2::Left => @math.Transform::flip_x(48.0)
        Direction2::Right => @math.Transform::new()
      }
      @sprite.play_animation(
        e,
        older_hurt_animation,
        transform=transform
      )
      continue
    } else if older.is_hurt && older.hurt_timer <= 0.0 {
      older.is_hurt = false
      older.state = OlderState::Idle
    }
    
    // æ£€æµ‹å‘¨å›´æ˜¯å¦æœ‰ç©å®¶
    let mut has_nearby_player = false
    let mut player_distance_squared = 1000000.0
    let detection_range = 150.0  // æ£€æµ‹èŒƒå›´
    let attack_range = 80.0      // æ”»å‡»èŒƒå›´
    
    match @position.positions.get(game_state.player) {
      Some(player_pos) => {
        let dx = player_pos.0[X] - older_pos.0[X]
        let dy = player_pos.0[Y] - older_pos.0[Y]
        let distance_squared = dx * dx + dy * dy
        player_distance_squared = distance_squared
        
        if distance_squared < detection_range * detection_range {
          has_nearby_player = true
          
          // å¦‚æœè¿˜æœªå¯¹è¯ï¼Œæ£€æµ‹Fé”®è§¦å‘å¯¹è¯
          if not(older.has_talked) {
            if @inputs.is_just_pressed(@inputs.KeyF) && not(is_dialogue_showing()) {
              show_dialogue("Older", "å“¼ï¼åˆä¸€ä¸ªä¸è‡ªé‡åŠ›çš„å†’é™©è€…...\nè®©æˆ‘æ¥æ•™è®­ä½ ï¼", Some(older_idle_animation))
              older.has_talked = true  // æ ‡è®°å·²å¯¹è¯
              println("ğŸ‘´ Older å¼€å§‹å¯¹è¯ï¼Œç°åœ¨ä¼šä¸»åŠ¨æ”»å‡»ï¼")
            }
          }
          
          // æ ¹æ®ç©å®¶ä½ç½®æ›´æ–°æ–¹å‘
          if dx < 0.0 {
            older.direction = Direction2::Left
          } else {
            older.direction = Direction2::Right
          }
        }
      }
      None => ()
    }
    
    // é—ªç°é€»è¾‘ï¼šåªæœ‰å¯¹è¯åæ‰ä¼šé—ªç°
    if older.has_talked && has_nearby_player && older.blink_timer <= 0.0 && player_distance_squared < Older_BLINK_RANGE * Older_BLINK_RANGE {
      match @position.positions.get(game_state.player) {
        Some(player_pos) => {
          // è®¡ç®—ç©å®¶èƒŒåçš„ä½ç½®
          let blink_offset = 60.0  // é—ªç°åˆ°ç©å®¶èƒŒå60åƒç´ 
          let blink_x = match game_state.direction {
            Direction2::Right => player_pos.0[X] - blink_offset  // ç©å®¶é¢å‘å³ï¼Œé—ªç°åˆ°å·¦è¾¹
            Direction2::Left => player_pos.0[X] + blink_offset   // ç©å®¶é¢å‘å·¦ï¼Œé—ªç°åˆ°å³è¾¹
          }
          let blink_y = player_pos.0[Y]  // ä¿æŒåŒæ ·çš„Yåæ ‡
          
          // æ‰§è¡Œé—ªç°
          @position.positions[e] = @math.Vec2D(blink_x, blink_y)
          older.blink_timer = Older_BLINK_COOLDOWN  // é‡ç½®å†·å´æ—¶é—´
          
          // æ›´æ–°Olderçš„æœå‘ï¼Œé¢å‘ç©å®¶
          older.direction = match game_state.direction {
            Direction2::Right => Direction2::Right  // ç©å®¶é¢å‘å³ï¼ŒOlderä¹Ÿé¢å‘å³
            Direction2::Left => Direction2::Left    // ç©å®¶é¢å‘å·¦ï¼ŒOlderä¹Ÿé¢å‘å·¦
          }
          
          println("ğŸ‘´ Older é—ªç°åˆ°ç©å®¶èƒŒåï¼ä½ç½®: (\{blink_x}, \{blink_y})")
        }
        None => ()
      }
    }
    
    // æ”»å‡»å†·å´é€’å‡ï¼ˆåœ¨æ‰€æœ‰çŠ¶æ€ä¸‹éƒ½æ‰§è¡Œï¼‰
    if older.attack_timer > 0.0 {
      older.attack_timer -= delta
    }
    
    // æ ¹æ®çŠ¶æ€æ‰§è¡Œä¸åŒçš„è¡Œä¸ºï¼ˆåªæœ‰å¯¹è¯åæ‰ä¼šæ”»å‡»ï¼‰
    if older.has_talked && player_distance_squared < attack_range * attack_range {
      // æ”»å‡»çŠ¶æ€
      older.state = OlderState::Attack
      @velocity.velocities[e] = @math.Vec2D(0.0, velocity.0[Y])
      
      // æ£€æŸ¥æ˜¯å¦å¯ä»¥æ”»å‡»ï¼ˆå†·å´å®Œæ¯• ä¸” ç©å®¶æ²¡æœ‰æ— æ•Œæ—¶é—´ï¼‰
      if older.attack_timer <= 0.0 && game_state.hurt_timer <= 0.0 {
        match @position.positions.get(game_state.player) {
          Some(player_pos) => {
            // è®¡ç®—æ”»å‡»èŒƒå›´å†…æ˜¯å¦åŒ…å«ç©å®¶
            let dx = player_pos.0[X] - older_pos.0[X]
            let dy = player_pos.0[Y] - older_pos.0[Y]
            let distance_squared = dx * dx + dy * dy
            
            if distance_squared < Older_ATTACK_RANGE * Older_ATTACK_RANGE {
              // æ£€æŸ¥æ”»å‡»æ–¹å‘æ˜¯å¦æ­£ç¡®
              let is_correct_direction = match older.direction {
                Direction2::Right => dx > 0.0  // ç©å®¶åœ¨Olderå³ä¾§
                Direction2::Left => dx < 0.0   // ç©å®¶åœ¨Olderå·¦ä¾§
              }
              
              if is_correct_direction {
                // å‡»ä¸­ç©å®¶ï¼Œè°ƒç”¨hurt_playerå‡½æ•°ï¼ˆä¼šè§¦å‘å—å‡»åŠ¨ç”»å’ŒéŸ³æ•ˆï¼‰
                hurt_player()
                older.attack_timer = 2.5  // è®¾ç½®2.5ç§’æ”»å‡»å†·å´
              }
            }
          }
          None => ()
        }
      }
      
      let transform = match older.direction {
        Direction2::Left => @math.Transform::flip_x(48.0)
        Direction2::Right => @math.Transform::new()
      }
      @sprite.play_animation(
        e,
        older_attack_animation,
        transform=transform
      )
    } else if older.has_talked && has_nearby_player {
      // å¥”è·‘çŠ¶æ€ - å‘ç©å®¶ç§»åŠ¨ï¼ˆåªæœ‰å¯¹è¯åæ‰ä¼šä¸»åŠ¨è¿½å‡»ï¼‰
      older.state = OlderState::Run
      
      let direction_multiplier = match older.direction {
        Direction2::Left => -1.0
        Direction2::Right => 1.0
      }
      let velocity_x = older.speed * direction_multiplier
      @velocity.velocities[e] = @math.Vec2D(velocity_x, velocity.0[Y])
      
      let transform = match older.direction {
        Direction2::Left => @math.Transform::flip_x(48.0)
        Direction2::Right => @math.Transform::new()
      }
      @sprite.play_animation(
        e,
        older_run_animation,
        transform=transform
      )
    } else {
      // ç©ºé—²çŠ¶æ€ - åŸåœ°å¾…æœºæˆ–ç¼“æ…¢å·¡é€»
      older.state = OlderState::Idle
      
      if not(older.has_talked) {
        // æœªå¯¹è¯æ—¶ï¼Œå®Œå…¨é™æ­¢
        @velocity.velocities[e] = @math.Vec2D(0.0, velocity.0[Y])
      } else {
        // å¯¹è¯åï¼Œå·¦å³å·¡é€»
        older.idle_timer += delta
        
        // æ¯ 2 ç§’æ”¹å˜ä¸€æ¬¡æ–¹å‘
        if older.idle_timer > 2.0 {
          older.idle_timer = 0.0
          older.direction = match older.direction {
            Direction2::Left => Direction2::Right
            Direction2::Right => Direction2::Left
          }
        }
        
        // æ…¢é€Ÿç§»åŠ¨
        let direction_multiplier = match older.direction {
          Direction2::Left => -1.0
          Direction2::Right => 1.0
        }
        let velocity_x = older.speed * 0.5 * direction_multiplier  // å·¡é€»é€Ÿåº¦æ˜¯å¥”è·‘é€Ÿåº¦çš„ä¸€åŠ
        @velocity.velocities[e] = @math.Vec2D(velocity_x, velocity.0[Y])
      }
      
      let transform = match older.direction {
        Direction2::Left => @math.Transform::flip_x(48.0)
        Direction2::Right => @math.Transform::new()
      }
      @sprite.play_animation(
        e,
        older_idle_animation,  // ä½¿ç”¨ idle åŠ¨ç”»è€Œä¸æ˜¯ run åŠ¨ç”»
        transform=transform
      )
    }
  }
}