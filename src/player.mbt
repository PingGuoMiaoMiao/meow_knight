let player_magic_attack_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts1/Effect and FX Pixel Part 12 Free/566.png",
    13,
    width=64.0,
    height=64.0,
  ),
  loop_=false,
  fps=2,
)
///|
let player_death_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour2/NoOutline/120x80_PNGSheets/_Death.png",
    10,
    width=120.0,
    height=80.0,
  ),
  loop_=false,
  fps=2,
)

///|
let player_idle_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour1/NoOutline/120x80_PNGSheets/_Idle.png",
    10,
    width=120.0,
    height=80.0,
  ),
  loop_=false,
  fps=12,
)

///|
let player_crouch_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour2/NoOutline/120x80_PNGSheets/_CrouchAll.png",
    3,
    width=120.0,
    height=80.0,
  ),
  loop_=true,
  fps=1,
)

///|
let player_roll_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour2/NoOutline/120x80_PNGSheets/_Roll.png",
    12,
    width=120.0,
    height=80.0,
  ),
  loop_=false,
  fps=12,
)

///|
let player_attack_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour2/NoOutline/120x80_PNGSheets/_Attack.png",
    4,
    width=120.0,
    height=80.0,
  ),
  loop_=false,
  fps=12,
)

///|
let player_attack2_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour2/NoOutline/120x80_PNGSheets/_Attack2.png",
    6,
    width=120.0,
    height=80.0,
  ),
  loop_=false,
  fps=12,
)

///|
let player_run_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour2/NoOutline/120x80_PNGSheets/_Run.png",
    10,
    width=120.0,
    height=80.0,
  ),
  loop_=true,  // è·‘æ­¥åŠ¨ç”»åº”è¯¥å¾ªç¯æ’­æ”¾
  fps=12,
)

///|
let player_fall_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour1/NoOutline/120x80_PNGSheets/_Fall.png",
    3,
    width=120.0,
    height=80.0,
  ),
  loop_=false,
  fps=1,
)

///|
let player_hit_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour2/NoOutline/120x80_PNGSheets/_Hit.png",
    1,
    width=120.0,
    height=80.0,
  ),
  loop_=false,
  fps=1,
)

///|
let player_jump_animation : @sprite.Animation = @sprite.Animation::new(
  @sprite.frames_from_atlas(
    "asserts/Colour2/NoOutline/120x80_PNGSheets/_Jump.png",
    3,
    width=120.0,
    height=80.0,
  ),
  loop_=false,
  fps=12,
)

///|
fn add_player(pos : @math.Vec2D) -> Unit {
  let player_sprite = @sprite.Sprite::from_animation(player_idle_animation, 10)
  @sprite.sprites.set(game_state.player, player_sprite)
  @velocity.velocities.set(game_state.player, @math.Vec2D::zero())
  @position.positions.set(game_state.player, pos)
  @collision.shapes.set(
    game_state.player,
    Rect(size=@math.Vec2D(120.0, 80.0), offset=@math.Vec2D(20, 0.0)),
  )
  @collision.collision_layers.set(game_state.player, player_collision_layer)
  @collision.colliders.set(
    game_state.player,
    @collision.Collider::new(
      @collision.CollisionMask::new([
        terrain_collision_layer,  // ä¸åœ°å½¢ç¢°æ’
        enemy_collision_layer,    // ä¸æ•Œäººç¢°æ’ï¼ˆæ£€æµ‹slimeç­‰æ•Œäººï¼‰
      ]),
    ),
  )
  @camera.attach_entity(game_state.player, @math.Vec2D(16.0, 16.0))
}

///|
enum PlayerState {
  Death
  Attack
  Idle
  Hit
  Jump
  Roll
  Fall
  Crouch
  MagicAttack
  
} derive(Show)

///|
const GRAVITY = 1800.0

///|
const MAX_RUN_V = 120.0  // æœ€å¤§è·‘æ­¥é€Ÿåº¦ï¼ˆä»160é™ä½åˆ°120ï¼‰

///|
const JUMP_V = 680.0

///|
const MAX_FALL_V = 900.0

///|
const RUN_ACC = 1800.0  // åŠ é€Ÿåº¦ï¼ˆä»2400é™ä½åˆ°1800ï¼‰ï¼Œè®©æ­¥ä¼æ›´å°

///|
const BUMP_V : Double = JUMP_V / 2.0

///|
const ROLL_SPEED = 300.0  // ç¿»æ»šæ—¶çš„å‰è¿›é€Ÿåº¦

///|
struct AttackState {
  mut is_attacking : Bool
  mut attack_type : Int // 1 for attack1, 2 for attack2
  mut attack_timer : Double
  mut has_hit : Bool // é˜²æ­¢ä¸€æ¬¡æ”»å‡»å¤šæ¬¡ä¼¤å®³
}

///|
let attack_state : AttackState = {
  is_attacking: false,
  attack_type: 0,
  attack_timer: 0.0,
  has_hit: false
}

///|
struct MagicProjectile {
  entity : @system.Entity
  mut timer : Double
  damage : Int
  direction : Direction2
}

///|
let magic_projectiles : Map[@system.Entity, MagicProjectile] = Map::new()

///|
const MAGIC_SPEED = 400.0  // é­”æ³•å¼¹ä¸¸é£è¡Œé€Ÿåº¦

///|
const MAGIC_DAMAGE = 30  // é­”æ³•å¼¹ä¸¸ä¼¤å®³

///|
const MAGIC_LIFETIME = 180.0  // é­”æ³•å¼¹ä¸¸å­˜åœ¨æ—¶é—´ï¼ˆ3ç§’ï¼‰

/// å¼€å§‹æ”»å‡» - è®¾ç½®æ”»å‡»çŠ¶æ€
///|
fn start_attack(attack_type : Int) -> Unit {
  attack_state.is_attacking = true
  attack_state.attack_type = attack_type
  attack_state.has_hit = false
  
  // è®¾ç½®æ”»å‡»æŒç»­æ—¶é—´ï¼ˆæ”»å‡»åŠ¨ç”»çš„æ´»è·ƒå¸§æ•°ï¼‰
  attack_state.attack_timer = match attack_type {
    1 => 15.0 // attack1 æŒç»­çº¦15å¸§
    2 => 20.0 // attack2 æŒç»­çº¦20å¸§  
    _ => 15.0
  }
}

/// æ›´æ–°æ”»å‡»ç³»ç»Ÿ - åŸºäºè¸©è¸é€»è¾‘çš„æ”»å‡»æ£€æµ‹
///|
fn update_attack_system(_delta : Double) -> Unit {
  if !attack_state.is_attacking {
    return
  }
  
  // å‡å°‘æ”»å‡»è®¡æ—¶å™¨
  attack_state.attack_timer -= 1.0
  
  // å¦‚æœè¿˜åœ¨æ”»å‡»æ—¶é—´å†…ä¸”å°šæœªå‘½ä¸­ï¼Œæ£€æµ‹æ”»å‡»
  if attack_state.attack_timer > 0.0 && !attack_state.has_hit {
    check_attack_collision()
  }
  
  // æ”»å‡»æ—¶é—´ç»“æŸï¼Œé‡ç½®æ”»å‡»çŠ¶æ€
  if attack_state.attack_timer <= 0.0 {
    attack_state.is_attacking = false
    attack_state.has_hit = false
  }
}

/// æ£€æµ‹æ”»å‡»ç¢°æ’ - ç›´æ¥èŒƒå›´æ£€æµ‹ï¼Œä¸ä¾èµ–ç¢°æ’ç³»ç»Ÿ
///|
fn check_attack_collision() -> Unit {
  // è·å–ç©å®¶ä½ç½®
  let player_pos = @position.positions.get(game_state.player).unwrap_or(@math.Vec2D::zero())
  
  // è®¾ç½®æ”»å‡»èŒƒå›´
  let attack_range = match attack_state.attack_type {
    1 => 120.0 // attack1 æ”»å‡»èŒƒå›´
    2 => 150.0 // attack2 æ”»å‡»èŒƒå›´
    _ => 120.0
  }
  
  // éå†æ‰€æœ‰éª·é«…ï¼Œæ£€æŸ¥æ˜¯å¦åœ¨æ”»å‡»èŒƒå›´å†…
  for entity, skeleton in skeletons {
    if skeleton.hurt_timer > 0.0 { 
      continue // è·³è¿‡æ— æ•ŒçŠ¶æ€çš„éª·é«…
    }
    
    let skeleton_pos = @position.positions.get(entity).unwrap_or(@math.Vec2D::zero())
    
    // è®¡ç®—è·ç¦»
    let dx = skeleton_pos.0[X] - player_pos.0[X]
    let dy = skeleton_pos.0[Y] - player_pos.0[Y]
    let distance = dx * dx + dy * dy // ä½¿ç”¨å¹³æ–¹è·ç¦»é¿å…å¼€æ–¹è®¡ç®—
    let max_distance = attack_range * attack_range
    
    // æ£€æŸ¥æ˜¯å¦åœ¨æ”»å‡»èŒƒå›´å†…
    if distance <= max_distance {
      // æ£€æŸ¥æ”»å‡»æ–¹å‘æ˜¯å¦æ­£ç¡®
      let is_correct_direction = match game_state.direction {
        Direction2::Right => dx > 0.0 // éª·é«…åœ¨ç©å®¶å³ä¾§
        Direction2::Left => dx < 0.0  // éª·é«…åœ¨ç©å®¶å·¦ä¾§
      }
      
      if is_correct_direction {
        // å¯¹éª·é«…é€ æˆä¼¤å®³
        let damage = match attack_state.attack_type {
          1 => 25 // attack1ä¼¤å®³
          2 => 40 // attack2ä¼¤å®³ 
          _ => 25
        }
        
        skeleton.is_hurt = true
        skeleton.hurt_timer = 60.0 // å—ä¼¤æ— æ•Œæ—¶é—´
        skeleton.health -= damage
        
        // ç»™éª·é«…ä¸€ä¸ªå‡»é€€æ•ˆæœ
        let knockback = match game_state.direction {
          Direction2::Right => @math.Vec2D(100.0, -50.0)
          Direction2::Left => @math.Vec2D(-100.0, -50.0)
        }
        @velocity.velocities[entity] = knockback
        
        attack_state.has_hit = true // æ ‡è®°å·²å‘½ä¸­ï¼Œé˜²æ­¢é‡å¤ä¼¤å®³
        
        if game_state.volume_on {
          @audio.play_audio("sounds/hurt.wav")
        }
        
        return // åªå‡»ä¸­ç¬¬ä¸€ä¸ªæ•Œäºº
      }
    }
  }
  
  // éå†æ‰€æœ‰slimeï¼Œæ£€æŸ¥æ˜¯å¦åœ¨æ”»å‡»èŒƒå›´å†…
  for entity, silme in silmes {
    if silme.hurt_timer > 0.0 { 
      continue // è·³è¿‡æ— æ•ŒçŠ¶æ€çš„slime
    }
    
    let silme_pos = @position.positions.get(entity).unwrap_or(@math.Vec2D::zero())
    
    // è®¡ç®—è·ç¦»
    let dx = silme_pos.0[X] - player_pos.0[X]
    let dy = silme_pos.0[Y] - player_pos.0[Y]
    let distance = dx * dx + dy * dy // ä½¿ç”¨å¹³æ–¹è·ç¦»é¿å…å¼€æ–¹è®¡ç®—
    let max_distance = attack_range * attack_range
    
    // æ£€æŸ¥æ˜¯å¦åœ¨æ”»å‡»èŒƒå›´å†…
    if distance <= max_distance {
      // æ£€æŸ¥æ”»å‡»æ–¹å‘æ˜¯å¦æ­£ç¡®
      let is_correct_direction = match game_state.direction {
        Direction2::Right => dx > 0.0 // slimeåœ¨ç©å®¶å³ä¾§
        Direction2::Left => dx < 0.0  // slimeåœ¨ç©å®¶å·¦ä¾§
      }
      
      if is_correct_direction {
        // å¯¹slimeé€ æˆä¼¤å®³
        let damage = match attack_state.attack_type {
          1 => 25 // attack1ä¼¤å®³
          2 => 40 // attack2ä¼¤å®³ 
          _ => 25
        }
        
        silme.is_hurt = true
        silme.hurt_timer = 60.0 // å—ä¼¤æ— æ•Œæ—¶é—´
        silme.health -= damage
        
        // ç»™slimeä¸€ä¸ªæ›´å¼ºçš„å‡»é€€æ•ˆæœï¼Œè®©å®ƒé£èµ·æ¥
        let knockback = match game_state.direction {
          Direction2::Right => @math.Vec2D(150.0, -300.0)  // å¢åŠ æ°´å¹³å’Œå‚ç›´å‡»é€€åŠ›åº¦
          Direction2::Left => @math.Vec2D(-150.0, -300.0)
        }
        @velocity.velocities[entity] = knockback
        
        attack_state.has_hit = true // æ ‡è®°å·²å‘½ä¸­ï¼Œé˜²æ­¢é‡å¤ä¼¤å®³
        
        if game_state.volume_on {
          @audio.play_audio("sounds/hurt.wav")
        }
        
        return // åªå‡»ä¸­ç¬¬ä¸€ä¸ªæ•Œäºº
      }
    }
  }
}

/// åˆ›å»ºé­”æ³•å¼¹ä¸¸
///|
fn create_magic_projectile() -> Unit {
  // è·å–ç©å®¶ä½ç½®
  let player_pos = @position.positions.get(game_state.player).unwrap_or(@math.Vec2D::zero())
  
  // åˆ›å»ºå¼¹ä¸¸å®ä½“
  let projectile_entity = @system.Entity::new()
  
  // è®¾ç½®å¼¹ä¸¸ä½ç½®ï¼ˆä»ç©å®¶å‰æ–¹å‘å°„ï¼‰
  let projectile_pos = match game_state.direction {
    Direction2::Right => @math.Vec2D(player_pos.0[X] + 80.0, player_pos.0[Y] + 20.0)
    Direction2::Left => @math.Vec2D(player_pos.0[X] - 80.0, player_pos.0[Y] + 20.0)
  }
  
  // è®¾ç½®å¼¹ä¸¸é€Ÿåº¦
  let projectile_velocity = match game_state.direction {
    Direction2::Right => @math.Vec2D(MAGIC_SPEED, 0.0)
    Direction2::Left => @math.Vec2D(-MAGIC_SPEED, 0.0)
  }
  
  // è®¾ç½®å¼¹ä¸¸åŠ¨ç”»å’Œå±æ€§
  let projectile_sprite = @sprite.Sprite::from_animation(player_magic_attack_animation, 10)
  @sprite.sprites.set(projectile_entity, projectile_sprite)
  @position.positions.set(projectile_entity, projectile_pos)
  @velocity.velocities.set(projectile_entity, projectile_velocity)
  
  // è®¾ç½®å¼¹ä¸¸ç¢°æ’æ£€æµ‹
  @collision.shapes.set(
    projectile_entity,
    Rect(size=@math.Vec2D(32.0, 32.0), offset=@math.Vec2D(0.0, 0.0))
  )
  @collision.collision_layers.set(projectile_entity, player_collision_layer)
  @collision.colliders.set(
    projectile_entity,
    @collision.Collider::new(
      @collision.CollisionMask::new([enemy_collision_layer, terrain_collision_layer])
    )
  )
  
  // æ·»åŠ åˆ°å¼¹ä¸¸ç®¡ç†åˆ—è¡¨
  magic_projectiles[projectile_entity] = {
    entity: projectile_entity,
    timer: MAGIC_LIFETIME,
    damage: MAGIC_DAMAGE,
    direction: game_state.direction
  }
}

/// æ›´æ–°é­”æ³•å¼¹ä¸¸ç³»ç»Ÿ
///|
fn update_magic_projectiles(_delta : Double) -> Unit {
  let to_remove : Array[@system.Entity] = []
  
  for entity, projectile in magic_projectiles {
    // æ£€æŸ¥å¼¹ä¸¸æ˜¯å¦è¿˜å­˜æ´»
    if !entity.is_alive() {
      to_remove.push(entity)
      continue
    }
    
    // å‡å°‘ç”Ÿå­˜æ—¶é—´
    projectile.timer -= 1.0
    if projectile.timer <= 0.0 {
      entity.destroy()
      to_remove.push(entity)
      continue
    }
    
    // æ£€æµ‹å¼¹ä¸¸ä¸æ•Œäººçš„ç¢°æ’
    let projectile_collisions = @collision.get_collision_infos(entity)
    for collision in projectile_collisions {
      // æ£€æµ‹éª·é«…
      if skeletons.get(collision.entity) is Some(skeleton) {
        if skeleton.hurt_timer <= 0.0 {
          // å¯¹éª·é«…é€ æˆä¼¤å®³
          skeleton.is_hurt = true
          skeleton.hurt_timer = 60.0
          skeleton.health -= projectile.damage
          
          // ç»™éª·é«…ä¸€ä¸ªå‡»é€€æ•ˆæœ
          let knockback = match projectile.direction {
            Direction2::Right => @math.Vec2D(80.0, -30.0)
            Direction2::Left => @math.Vec2D(-80.0, -30.0)
          }
          @velocity.velocities[collision.entity] = knockback
          
          if game_state.volume_on {
            @audio.play_audio("sounds/hurt.wav")
          }
          
          // é”€æ¯å¼¹ä¸¸
          entity.destroy()
          to_remove.push(entity)
          break
        }
      } else if silmes.get(collision.entity) is Some(silme) {
        // æ£€æµ‹slime
        if silme.hurt_timer <= 0.0 {
          // å¯¹slimeé€ æˆä¼¤å®³
          silme.is_hurt = true
          silme.hurt_timer = 60.0
          silme.health -= projectile.damage
          
          // ç»™slimeä¸€ä¸ªæ›´å¼ºçš„å‡»é€€æ•ˆæœ
          let knockback = match projectile.direction {
            Direction2::Right => @math.Vec2D(120.0, -250.0)  // å¢åŠ å‡»é€€åŠ›åº¦
            Direction2::Left => @math.Vec2D(-120.0, -250.0)
          }
          @velocity.velocities[collision.entity] = knockback
          
          if game_state.volume_on {
            @audio.play_audio("sounds/hurt.wav")
          }
          
          // é”€æ¯å¼¹ä¸¸
          entity.destroy()
          to_remove.push(entity)
          break
        }
      } else if collision.entity != game_state.player { // æ’åˆ°åœ°å½¢æˆ–å…¶ä»–ç‰©ä½“
        entity.destroy()
        to_remove.push(entity)
        break
      }
    }
  }
  
  // æ¸…ç†å·²é”€æ¯çš„å¼¹ä¸¸
  for entity in to_remove {
    magic_projectiles.remove(entity)
  }
}

///|
fn player_collision_system(_delta : Double) -> Unit {
  if game_state.hurt_timer > 0.0 {
    game_state.hurt_timer -= 1.0
  }
  
  // æ›´æ–°ç¿»æ»šå†·å´æ—¶é—´
  if game_state.roll_cooldown > 0.0 {
    game_state.roll_cooldown -= 1.0
  }
  
  // æ›´æ–°æ”»å‡»ç³»ç»Ÿ
  update_attack_system(_delta)
  
  // æ›´æ–°é­”æ³•å¼¹ä¸¸ç³»ç»Ÿ
  update_magic_projectiles(_delta)
  
  // // æ›´æ–°Unknownå—ç§»åŠ¨
  // update_unknown_blocks(_delta)
  
  let player_collision = @collision.get_collision_infos(game_state.player)
  for collision in player_collision {
    // å¤„ç†éª·é«…ç¢°æ’
    if skeletons.get(collision.entity) is Some(skeleton) {
      // åªæœ‰å½“éª·é«…ä¸åœ¨å—ä¼¤çŠ¶æ€æ—¶æ‰èƒ½ä¼¤å®³ç©å®¶
      if skeleton.hurt_timer <= 0.0 {
        if collision.direction[Y] > 0.0 {
          // è¸©è¸æ”»å‡» - å§‹ç»ˆæœ‰æ•ˆ
          skeleton.is_hurt = true
          skeleton.hurt_timer = 60.0
          skeleton.health -= 50 // è¸©è¸ä¼¤å®³
          guard @velocity.velocities.get(game_state.player) is Some(velocity)
          @velocity.velocities[game_state.player] = velocity.0.update(Y, -BUMP_V)
        } else {
          // ä¾§é¢ç¢°æ’ - ç¿»æ»šæ—¶å¯ä»¥ç©¿è¿‡æ•Œäºº
          if !(game_state.player_state is Roll) {
            hurt_player()
          }
        }
      }
    }
    
    // å¤„ç†slimeç¢°æ’
    if silmes.get(collision.entity) is Some(silme) {
      // åªæœ‰å½“slimeä¸åœ¨å—ä¼¤çŠ¶æ€æ—¶æ‰èƒ½ä¼¤å®³ç©å®¶
      if silme.hurt_timer <= 0.0 {
        if collision.direction[Y] > 0.0 {
          // è¸©è¸æ”»å‡» - å§‹ç»ˆæœ‰æ•ˆ
          silme.is_hurt = true
          silme.hurt_timer = 60.0
          silme.health -= 50 // è¸©è¸ä¼¤å®³
          
          // ç»™slimeä¸€ä¸ªå‘ä¸‹çš„å‹åŠ›ï¼Œç„¶åä¼šè‡ªç„¶å¼¹èµ·
          @velocity.velocities[collision.entity] = @math.Vec2D(0.0, 100.0)
          
          guard @velocity.velocities.get(game_state.player) is Some(velocity)
          @velocity.velocities[game_state.player] = velocity.0.update(Y, -BUMP_V)
          
          if game_state.volume_on {
            @audio.play_audio("sounds/hurt.wav")
          }
        } else {
          // ä¾§é¢ç¢°æ’ - ç¿»æ»šæ—¶å¯ä»¥ç©¿è¿‡æ•Œäºº
          if !(game_state.player_state is Roll) {
            hurt_player()
          }
        }
      }
    }
    
    // // å¤„ç†Unknownå—ç¢°æ’
    // if unknown_blocks.get(collision.entity) is Some(unknown_block) {
    //   // è·å–ç©å®¶å’ŒUnknownå—çš„ä½ç½®ä¿¡æ¯
    //   let player_pos = @position.positions.get(game_state.player).unwrap_or(@math.Vec2D::zero())
    //   let unknown_pos = @position.positions.get(collision.entity).unwrap_or(@math.Vec2D::zero())
    //   let player_velocity = @velocity.velocities.get(game_state.player).unwrap_or(@math.Vec2D::zero())
      
    //   println("ğŸ” ç¢°æ’æ£€æµ‹: ç©å®¶Y=" + player_pos.0[@math.Axis::Y].to_string() + ", Unknown Y=" + unknown_pos.0[@math.Axis::Y].to_string() + ", ç©å®¶é€Ÿåº¦Y=" + player_velocity.0[@math.Axis::Y].to_string())
    //   println("ğŸ” ç¢°æ’æ–¹å‘: " + collision.direction[@math.Axis::Y].to_string())
      
    //   // æ£€æŸ¥æ¡ä»¶ï¼šç©å®¶ä»ä¸‹æ–¹å‘ä¸Šæ’å‡»Unknownå—çš„åº•éƒ¨
    //   // 1. ç©å®¶åœ¨Unknownå—ä¸‹æ–¹ (player_y + player_height > unknown_y)
    //   // 2. ç©å®¶å‘ä¸Šè¿åŠ¨ (velocity_y < 0)
    //   // 3. ç¢°æ’æ–¹å‘æ˜¯å‘ä¸Šæ’å‡» (collision.direction[Y] > 0.0 è¡¨ç¤ºç©å®¶ä»ä¸‹å¾€ä¸Šæ’)
    //   // 4. Unknownå—æ²¡æœ‰åœ¨ç§»åŠ¨
    //   let player_bottom = player_pos.0[@math.Axis::Y] + 80.0 // ç©å®¶é«˜åº¦80
    //   let unknown_bottom = unknown_pos.0[@math.Axis::Y] + 16.0 // Unknowné«˜åº¦16
      
    //   if player_bottom > unknown_pos.0[@math.Axis::Y] && // ç©å®¶åº•éƒ¨åœ¨Unknowné¡¶éƒ¨ä¸‹æ–¹
    //      player_pos.0[@math.Axis::Y] < unknown_bottom && // ç©å®¶é¡¶éƒ¨åœ¨Unknownåº•éƒ¨ä¸Šæ–¹
    //      player_velocity.0[@math.Axis::Y] < 0.0 && // ç©å®¶å‘ä¸Šç§»åŠ¨
    //      collision.direction[@math.Axis::Y] > 0.0 && // ç¢°æ’æ–¹å‘å‘ä¸Š
    //      !unknown_block.is_moving {
    //     // ç©å®¶ä»ä¸‹æ–¹è·³è·ƒé¡¶åˆ°Unknownå—ï¼
    //     println("ğŸŸ« ç©å®¶ä»ä¸‹æ–¹é¡¶åˆ°Unknownå—ï¼è§¦å‘åŠ¨ç”»ï¼")
    //     unknown_block.is_moving = true
    //     unknown_block.current_phase = 1 // å¼€å§‹å‘ä¸Šç§»åŠ¨
    //     unknown_block.move_timer = 0.0
        
    //     // ç»™ç©å®¶ä¸€ä¸ªåå¼¹æ•ˆæœ
    //     guard @velocity.velocities.get(game_state.player) is Some(velocity)
    //     @velocity.velocities[game_state.player] = velocity.0.update(@math.Axis::Y, -BUMP_V)
    //   }
    // }
  }
}

///|
fn player_state_system(delta : Double) -> Unit {
  // æ£€æŸ¥Eé”®æ‹¾å–é‡‘å¸
  if @inputs.is_just_pressed(@inputs.KeyE) {
    try_pickup_coin()
  }
  
  let velocity = @collision.real_velocities
    .get(game_state.player)
    .unwrap_or(@math.Vec2D::zero())
  let mut new_velocity_x = velocity.0[X]
  let mut new_velocity_y = velocity.0[Y]
  
  // æ›´æ–°ä¸Šæ¬¡æŒ‰é”®æ—¶é—´è®¡æ—¶å™¨ï¼ˆåªåœ¨æœ‰æ•ˆèŒƒå›´å†…å¢åŠ ï¼‰
  if game_state.last_down_press_time > 0.0 && game_state.last_down_press_time < 100.0 {
    game_state.last_down_press_time += 1.0
  }
  
  // åªæœ‰åœ¨éå—ä¼¤ã€éæ”»å‡»ã€éç¿»æ»šçŠ¶æ€æ—¶æ‰èƒ½æ§åˆ¶ç§»åŠ¨
  if !(game_state.player_state is Hit) && 
     !(game_state.player_state is Attack) && 
     !(game_state.player_state is MagicAttack) &&
     !(game_state.player_state is Roll) {
    if @inputs.is_pressed(@inputs.ArrowLeft) || @inputs.is_pressed(@inputs.KeyA) {
      new_velocity_x -= RUN_ACC * delta
      if new_velocity_x < -MAX_RUN_V {
        new_velocity_x = -MAX_RUN_V
      }
      game_state.direction = Direction2::Left
    } else if @inputs.is_pressed(@inputs.ArrowRight) ||
      @inputs.is_pressed(@inputs.KeyD) {
      new_velocity_x += RUN_ACC * delta
      if new_velocity_x > MAX_RUN_V {
        new_velocity_x = MAX_RUN_V
      }
      game_state.direction = Direction2::Right
    } else {
      new_velocity_x = 0.0
    }
  }
  let transform = match game_state.direction {
    Direction2::Left => @math.Transform::flip_x(32.0)
    Direction2::Right => @math.Transform::new()
  }
  match game_state.player_state {
    Death => {
      @sprite.play_animation(
        game_state.player,
        player_death_animation,
        transform~,
      )
      if @sprite.is_animation_finished(game_state.player) {
        if game_state.volume_on {
          @audio.play_audio("sounds/death.wav")
        }
      }
    }
    Crouch => {
      @sprite.play_animation(
        game_state.player,
        player_crouch_animation,
        transform~,
      )
      
      // æ£€æŸ¥åŒå‡»è§¦å‘ç¿»æ»š
      if (@inputs.is_just_pressed(ArrowDown) || @inputs.is_just_pressed(KeyS)) &&
         game_state.roll_cooldown <= 0.0 {
        // åœ¨ä¸‹è¹²çŠ¶æ€ä¸‹å†æ¬¡æŒ‰ä¸‹ï¼Œè§¦å‘ç¿»æ»š
        if @inputs.is_pressed(@inputs.ArrowLeft) || @inputs.is_pressed(@inputs.KeyA) {
          game_state.direction = Direction2::Left
        } else if @inputs.is_pressed(@inputs.ArrowRight) || @inputs.is_pressed(@inputs.KeyD) {
          game_state.direction = Direction2::Right
        }
        
        game_state.player_state = PlayerState::Roll
        game_state.roll_cooldown = 90.0
        game_state.last_down_press_time = -999.0
        
        if game_state.volume_on {
          @audio.play_audio("sounds/roll.wav")
        }
      } else if !@inputs.is_pressed(ArrowDown) && !@inputs.is_pressed(KeyS) {
        // ä¸¤ä¸ªé”®éƒ½æ²¡æŒ‰æ‰é€€å‡ºä¸‹è¹²çŠ¶æ€
        game_state.player_state = PlayerState::Idle
        game_state.last_down_press_time = -999.0  // é‡ç½®è®¡æ—¶å™¨
      }
    }
    Roll => {
      @sprite.play_animation(
        game_state.player,
        player_roll_animation,
        transform~,
      )
      
      // ç¿»æ»šæ—¶ç»™ç©å®¶ä¸€ä¸ªå‘å‰çš„é€Ÿåº¦
      new_velocity_x = match game_state.direction {
        Direction2::Right => ROLL_SPEED
        Direction2::Left => -ROLL_SPEED
      }
      
      // ç¿»æ»šæ—¶ä¿®æ”¹ç¢°æ’æ©ç ï¼Œè®©ç©å®¶ä¸ä¼šä¸æ•Œäººå‘ç”Ÿç‰©ç†ç¢°æ’
      @collision.colliders.set(
        game_state.player,
        @collision.Collider::new(
          @collision.CollisionMask::new([terrain_collision_layer]) // åªä¸åœ°å½¢ç¢°æ’ï¼Œå¿½ç•¥æ•Œäºº
        )
      )
      
      if @sprite.is_animation_finished(game_state.player) {
        // ç¿»æ»šç»“æŸåæ£€æŸ¥æ˜¯å¦åœ¨ç©ºä¸­
        if @collision.is_on_floor(game_state.player) {
          game_state.player_state = PlayerState::Idle
        } else if velocity.0[Y] > 0.0 {
          game_state.player_state = PlayerState::Fall
        } else {
          game_state.player_state = PlayerState::Jump
        }
        
        // ç¿»æ»šç»“æŸï¼Œæ¢å¤æ­£å¸¸çš„ç¢°æ’æ©ç 
        @collision.colliders.set(
          game_state.player,
          @collision.Collider::new(
            @collision.CollisionMask::new([
              terrain_collision_layer, enemy_collision_layer,
            ])
          )
        )
      }
    }
    Attack => {
      // æ”»å‡»æ—¶åœæ­¢æ°´å¹³ç§»åŠ¨
      new_velocity_x = 0.0
      
      if game_state.attack_hit_count == 1 {
        @sprite.play_animation(
          game_state.player,
          player_attack_animation,
          transform~,
        )
      } else if game_state.attack_hit_count == 2 {
        @sprite.play_animation(
          game_state.player,
          player_attack2_animation,
          transform~,
        )
        game_state.attack_hit_count = 0
      }
      if @sprite.is_animation_finished(game_state.player) {
        // æ”»å‡»ç»“æŸåæ£€æŸ¥æ˜¯å¦åœ¨ç©ºä¸­
        if @collision.is_on_floor(game_state.player) {
          game_state.player_state = PlayerState::Idle
        } else if velocity.0[Y] > 0.0 {
          game_state.player_state = PlayerState::Fall
        } else {
          game_state.player_state = PlayerState::Jump
        }
      }
    }
    MagicAttack => {
      // é­”æ³•æ”»å‡»æ—¶åœæ­¢æ°´å¹³ç§»åŠ¨
      new_velocity_x = 0.0
      
      @sprite.play_animation(
        game_state.player,
        player_attack_animation, // ä½¿ç”¨æ™®é€šæ”»å‡»åŠ¨ç”»ä½œä¸ºé­”æ³•æ”»å‡»åŠ¨ç”»
        transform~,
      )
      if @sprite.is_animation_finished(game_state.player) {
        // é­”æ³•æ”»å‡»ç»“æŸåæ£€æŸ¥æ˜¯å¦åœ¨ç©ºä¸­
        if @collision.is_on_floor(game_state.player) {
          game_state.player_state = PlayerState::Idle
        } else if velocity.0[Y] > 0.0 {
          game_state.player_state = PlayerState::Fall
        } else {
          game_state.player_state = PlayerState::Jump
        }
      }
    }
    Idle => {
      // æ£€æŸ¥æ˜¯å¦æœ‰æ°´å¹³è¾“å…¥æ¥å†³å®šåŠ¨ç”»
      let has_horizontal_input = @inputs.is_pressed(@inputs.ArrowLeft) ||
                                  @inputs.is_pressed(@inputs.KeyA) ||
                                  @inputs.is_pressed(@inputs.ArrowRight) ||
                                  @inputs.is_pressed(@inputs.KeyD)
      
      if has_horizontal_input && velocity.0[X].abs() > 10.0 {
        @sprite.play_animation(
          game_state.player,
          player_run_animation,
          transform~,
        )
      } else {
        @sprite.play_animation(
          game_state.player,
          player_idle_animation,
          transform~,
        )
      }
      
      // æ£€æŸ¥æ˜¯å¦ç¦»å¼€åœ°é¢
      if velocity.0[Y] > 0.0 {
        game_state.player_state = PlayerState::Fall
      }
      
      // è·³è·ƒè¾“å…¥
      if (@inputs.is_just_pressed(ArrowUp) || @inputs.is_just_pressed(KeyW)) &&
        @collision.is_on_floor(game_state.player) {
        new_velocity_y = -JUMP_V
        game_state.player_state = PlayerState::Jump
        if game_state.volume_on {
          @audio.play_audio("sounds/jump.wav")
        }
      }
      
      // ä¸‹è¹²/ç¿»æ»šè¾“å…¥ï¼ˆæ”¯æŒä¸¤ç§æ–¹å¼ï¼‰
      if @inputs.is_just_pressed(ArrowDown) || @inputs.is_just_pressed(KeyS) {
        // æ£€æŸ¥æ˜¯å¦åœ¨åŒå‡»æ—¶é—´çª—å£å†…ï¼ˆ20å¸§ â‰ˆ 0.33ç§’ï¼‰
        if game_state.last_down_press_time > 0.0 && 
           game_state.last_down_press_time < 20.0 && 
           game_state.roll_cooldown <= 0.0 {
          // åŒå‡»æ£€æµ‹æˆåŠŸï¼Œç›´æ¥è§¦å‘ç¿»æ»š
          if @inputs.is_pressed(@inputs.ArrowLeft) || @inputs.is_pressed(@inputs.KeyA) {
            game_state.direction = Direction2::Left
          } else if @inputs.is_pressed(@inputs.ArrowRight) || @inputs.is_pressed(@inputs.KeyD) {
            game_state.direction = Direction2::Right
          }
          
          game_state.player_state = PlayerState::Roll
          game_state.roll_cooldown = 90.0 // 1.5ç§’å†·å´æ—¶é—´ (90å¸§ @ 60fps)
          game_state.last_down_press_time = -999.0  // é‡ç½®è®¡æ—¶å™¨
          
          if game_state.volume_on {
            @audio.play_audio("sounds/roll.wav")
          }
        } else {
          // ç¬¬ä¸€æ¬¡æŒ‰ä¸‹æˆ–è¶…æ—¶ï¼Œè¿›å…¥ä¸‹è¹²çŠ¶æ€
          game_state.player_state = PlayerState::Crouch
          game_state.last_down_press_time = 1.0  // å¼€å§‹è®¡æ—¶ï¼ˆä»1å¼€å§‹ï¼Œé¿å…å’Œ0å†²çªï¼‰
        }
      }
      
      // æ”»å‡»è¾“å…¥
      if @inputs.is_just_pressed(KeyJ) {
        game_state.player_state = PlayerState::Attack
        game_state.attack_hit_count += 1
        
        // å¼€å§‹æ”»å‡»
        start_attack(game_state.attack_hit_count)
        
        if game_state.volume_on {
          @audio.play_audio("sounds/jump.wav") // ç”¨è·³è·ƒéŸ³æ•ˆæ¥æ ‡è¯†æ”»å‡»å¼€å§‹
        }
      }
      
      // é­”æ³•æ”»å‡»è¾“å…¥
      if @inputs.is_just_pressed(KeyK) {
        game_state.player_state = PlayerState::MagicAttack
        
        // åˆ›å»ºé­”æ³•å¼¹ä¸¸
        create_magic_projectile()
        
        if game_state.volume_on {
          @audio.play_audio("sounds/power_up.wav") // ç”¨èƒ½é‡éŸ³æ•ˆæ¥æ ‡è¯†é­”æ³•æ”»å‡»
        }
      }
    }
    Fall => {
      @sprite.play_animation(
        game_state.player,
        player_fall_animation,
        transform~,
      )
      if @collision.is_on_floor(game_state.player) {
        game_state.player_state = PlayerState::Idle
      }
    }
    Jump => {
      @sprite.play_animation(
        game_state.player,
        player_jump_animation,
        transform~,
      )
      if velocity.0[Y] > 0.0 {
        game_state.player_state = PlayerState::Fall
      }
    }
    Hit => {
      @sprite.play_animation(
        game_state.player,
        player_hit_animation,
        transform~,
      )
      if @collision.is_on_floor(game_state.player) {
        new_velocity_x = 0.0
      }
      if @sprite.is_animation_finished(game_state.player) {
        if @collision.is_on_floor(game_state.player) {
          game_state.player_state = PlayerState::Idle
        } else if velocity.0[Y] < 0.0 {
          game_state.player_state = PlayerState::Fall
        } else {
          game_state.player_state = PlayerState::Jump
        }
      }
    }
  }
  new_velocity_y += GRAVITY * delta
  if new_velocity_y > MAX_FALL_V {
    new_velocity_y = MAX_FALL_V
  }
  @velocity.velocities[game_state.player] = @math.Vec2D(
    new_velocity_x, new_velocity_y,
  )
}

/// æ›´æ–°Unknownå—çš„ç§»åŠ¨ç³»ç»Ÿ
// ///|
// fn update_unknown_blocks(_delta : Double) -> Unit {
//   for entity, unknown_block in unknown_blocks {
//     if !unknown_block.is_moving {
//       continue
//     }
    
//     unknown_block.move_timer += _delta * 60.0 // è½¬æ¢ä¸ºå¸§æ•°
    
//     match unknown_block.current_phase {
//       1 => {
//         // å‘ä¸Šç§»åŠ¨é˜¶æ®µ
//         let progress = unknown_block.move_timer / 15.0 // 15å¸§å®Œæˆå‘ä¸Šç§»åŠ¨
//         if progress >= 1.0 {
//           // ç§»åŠ¨å®Œæˆï¼Œè®¾ç½®åˆ°ç›®æ ‡ä½ç½®
//           let target_pos = @math.Vec2D(
//             unknown_block.original_pos[@math.Axis::X],
//             unknown_block.original_pos[@math.Axis::Y] - 8.0  // å‘ä¸Šç§»åŠ¨åŠä¸ªUnknownä½ç½® (16/2=8)
//           )
//           @position.positions[entity] = target_pos
//           unknown_block.current_phase = 2 // è¿›å…¥åœç•™é˜¶æ®µ
//           unknown_block.move_timer = 0.0
//         } else {
//           // å¹³æ»‘å‘ä¸Šç§»åŠ¨
//           let current_y = unknown_block.original_pos[@math.Axis::Y] - (8.0 * progress)
//           let current_pos = @math.Vec2D(
//             unknown_block.original_pos[@math.Axis::X],
//             current_y
//           )
//           @position.positions[entity] = current_pos
//         }
//       }
//       2 => {
//         // åœç•™é˜¶æ®µ
//         if unknown_block.move_timer >= 30.0 { // åœç•™30å¸§ (0.5ç§’)
//           unknown_block.current_phase = 3 // è¿›å…¥å‘ä¸‹ç§»åŠ¨é˜¶æ®µ
//           unknown_block.move_timer = 0.0
//         }
//       }
//       3 => {
//         // å‘ä¸‹ç§»åŠ¨é˜¶æ®µ
//         let progress = unknown_block.move_timer / 15.0 // 15å¸§å®Œæˆå‘ä¸‹ç§»åŠ¨
//         if progress >= 1.0 {
//           // ç§»åŠ¨å®Œæˆï¼Œå›åˆ°åŸä½
//           @position.positions[entity] = unknown_block.original_pos
//           unknown_block.current_phase = 0
//           unknown_block.is_moving = false
//           unknown_block.move_timer = 0.0
//         } else {
//           // å¹³æ»‘å‘ä¸‹ç§»åŠ¨
//           let start_y = unknown_block.original_pos[@math.Axis::Y] - 8.0
//           let current_y = start_y + (8.0 * progress)
//           let current_pos = @math.Vec2D(
//             unknown_block.original_pos[@math.Axis::X],
//             current_y
//           )
//           @position.positions[entity] = current_pos
//         }
//       }
//       _ => ignore(()) // é»˜è®¤æƒ…å†µï¼Œä¸åšä»»ä½•æ“ä½œ
//     }
//   }
// }
